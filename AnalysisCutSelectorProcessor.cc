#include "AnalysisCutSelectorProcessor.h"

//MARLIN
#include "HistogramWidthExtractionTools.h"
#include "TrackFitterBase.h"
#include <cmath>

#include "marlin/Global.h"

#include "gear/GearMgr.h"
#include "gear/gearxml/GearXML.h"
#include "gear/TPCModule.h"
#include "gearimpl/Vectors.h"
#include "gear/TPCParameters.h"
#include "IntersectionCalculator.h"


using namespace lcio ;
using namespace marlin ;

namespace marlintpc{

AnalysisCutSelectorProcessor aAnalysisCutSelectorProcessor ;


AnalysisCutSelectorProcessor::AnalysisCutSelectorProcessor() : Processor("AnalysisCutSelectorProcessor")
, _cutFlowEvents(0), _cutFlowTracks(0), _hitZPosition(0), _hitTime(0), _runZPosTuple(0), _runHitTimeTuple(0)
{

	/* Description of the processor which will be displayed in the
	 * steering file automatically generated by
	 * marlin (use Marlin -x )
	 */
	_description = "AnalysisCutSelectorProcessor applies cuts on all track parameters for further analysis";


	/* register steering parameters: name, description, class-variable, default value
	 * the type will by defined by the type of the default value
	 * string, double, float and int are possible
	 * Please note to get a float you must cast in C++: (float) 1.3
	 */
	registerInputCollection( LCIO::TRACK,
			"InputCollectionName" ,
			"Name of the input collection"  ,
			_inputColName ,
			std::string("TPCTracks") ) ;

	registerOutputCollection( LCIO::TRACK,
			"OutputCollectionName" ,
			"Name of the output collection"  ,
			_outputColName ,
			std::string("TPCTracksCut") ) ;

	registerProcessorParameter( "SetOutputTransient" ,
			"if not 0 the output collection is set transient, default 0"  ,
			_outputIsTransient,
			0);

	registerOptionalParameter( "lowCutNTracks" ,
			"lower cut on number of tracks"  ,
			_lowcutNTracks ,
			(int) 0. ) ;

	registerOptionalParameter( "highCutNTracks" ,
			"upper cut on number of tracks"  ,
			_highcutNTracks ,
			(int) 10. ) ;

	registerOptionalParameter( "lowCutNHitsOnTrack" ,
			"lower cut on number of hits on track"  ,
			_lowcutNHitsOnTrack ,
			(int) 0. ) ;

	registerOptionalParameter( "highCutNHitsOnTrack" ,
			"upper cut on number of hits on track"  ,
			_highcutNHitsOnTrack ,
			(int) 10. ) ;
	
	registerOptionalParameter( "lowCutChiSq" ,
			"lower cut on chi square"  ,
			_lowcutChiSq ,
			(float) -1. ) ;

	registerOptionalParameter( "highCutChiSq" ,
			"higher cut on chi square"  ,
			_highcutChiSq ,
			(float) -1. ) ;
	
	registerOptionalParameter( "lowCutPhi" ,
			"lower cut on phi"  ,
			_lowcutPhi ,
			(float) -1. ) ;

	registerOptionalParameter( "highCutPhi" ,
			"upper cut on phi"  ,
			_highcutPhi ,
			(float) 1. ) ;

	registerOptionalParameter( "lowCutTanLambda" ,
			"lower cut on tan lambda"  ,
			_lowcutTanLambda ,
			(float) -1.7 ) ;

	registerOptionalParameter( "highCutTanLambda" ,
			"upper cut on tan lambda"  ,
			_highcutTanLambda ,
			(float) 1.7 ) ;

	registerOptionalParameter( "lowCutdEdx" ,
			"lower cut on dEdx"  ,
			_lowcutdEdx ,
			(float) 0. ) ;

	registerOptionalParameter( "highCutdEdx" ,
			"upper cut on dEdx"  ,
			_highcutdEdx ,
			(float) 100000. ) ;

	registerOptionalParameter( "lowCutD0" ,
			"lower cut on D0"  ,
			_lowcutD0 ,
			(float) 0. ) ;

	registerOptionalParameter( "highCutD0" ,
			"upper cut on D0"  ,
			_highcutD0 ,
			(float) 0. ) ;

	registerOptionalParameter( "lowCutZ0" ,
			"lower cut on Z0"  ,
			_lowcutZ0 ,
			(float) 0. ) ;

	registerOptionalParameter( "highCutZ0" ,
			"upper cut on Z0"  ,
			_highcutZ0 ,
			(float) 0. ) ;

	registerOptionalParameter( "lowCutOmega" ,
			"lower cut on Omega"  ,
			_lowcutOmega ,
			(float) 0. ) ;

	registerOptionalParameter( "highCutOmega" ,
			"upper cut on Omega"  ,
			_highcutOmega ,
			(float) 0. ) ;

	registerOptionalParameter( "RunZOverride" ,
			"User-supplied run Z"  ,
			_runZOverride ,
			(double) 0. ) ;

	registerOptionalParameter( "RunZErrorOverride" ,
			"User-supplied error on run Z"  ,
			_runZErrorOverride ,
			(double) 1. ) ;

	registerOptionalParameter( "zPosHistogramMax" ,
			"maximum for z-position histogram range (default: 600)"  ,
			_zPosHistogramMax ,
			(float) 600. ) ;

	registerProcessorParameter( "CutIfFitFailed" ,
			"cut if fit failed for a track (default: false)"  ,
			_cutIfFitFailed ,
			false ) ;

	registerProcessorParameter( "ModuleWithBestRow",
			"Module that has the best row (default:0)",
			_bestModule,
			int(0));

	registerProcessorParameter( "RowWithBestPerformance",
			"Row with the best resolution performance (default:0)",
			_bestRow,
			int(0));

}


void AnalysisCutSelectorProcessor::init()
{ 
	// usually a good idea to
	printParameters() ;
	AIDAProcessor::tree(this);
	_cutFlowEvents = new TH1F ("cutFlowEvents", "cut flow on events", 2, 0, 2 );
	_cutFlowEvents->GetXaxis()->SetTitle("cut number");
	_cutFlowEvents->GetYaxis()->SetTitle("# events left");

	_cutFlowTracks = new TH1F ("cutFlowTracks", "cut flow on tracks", 10, 0, 10 );
	_cutFlowTracks->GetXaxis()->SetTitle("cut number");
	_cutFlowTracks->GetYaxis()->SetTitle("# events left");

	if(!parameterSet("zPosHistogramMax")){
	  _hitZPosition = new TH1F ( "hitZPosition", "z position of hits", 1024, 0, 600 );
	}
	else{ 	// for drift-distances > 600, adjust histogram range (and bin number if needed)
	  _hitZPosition = new TH1F ( "hitZPosition", "z position of hits", 
				     (_zPosHistogramMax <= 1024)*1024 + (_zPosHistogramMax > 1024)*4096, 
				     0, _zPosHistogramMax );
	}
	_hitZPosition->GetXaxis()->SetTitle("hit z position [mm]");
	_hitZPosition->GetYaxis()->SetTitle("# hits");

	_hitTime = new TH1F ( "hitTime", "time of hits", 5096, 0, 10000 );
	_hitTime->GetXaxis()->SetTitle("hit time [ns]");
	_hitTime->GetYaxis()->SetTitle("# hits");

	_hitPhi = new TH1F ( "hitPhi", "phi of hits", 2048, 0,0 );
	_hitPhi->GetXaxis()->SetTitle("hit phi [rad]");
	_hitPhi->GetYaxis()->SetTitle("# hits");

	_hitPhiBestRow = new TH1F ( "hitPhiBestRow", "phi of hits of the best row", 2048, 0,0 );
	_hitPhiBestRow->GetXaxis()->SetTitle("hit phi [rad]");
	_hitPhiBestRow->GetYaxis()->SetTitle("# hits");

	_runZPosTuple=new TNtuple("RunZPositions","RunZPositions","mean90:mean90Error:rms90:rms90Error:mean90RangeMin:mean90RangeMax:nEntries");
	_runHitTimeTuple=new TNtuple("HitTime","HitTime","mean90:mean90Error:rms90:rms90Error:mean90RangeMin:mean90RangeMax:nEntries");
	
	_runHitPhiTuple=new TNtuple("HitPhi","HitPhi","mean90:mean90Error:rms90:rms90Error:mean90RangeMin:mean90RangeMax:nEntries");
	_runHitPhiBestRowTuple=new TNtuple("HitPhiBestRow","HitPhiBestRow","module:row:mean90:mean90Error:rms90:rms90Error:mean90RangeMin:mean90RangeMax:nEntries");

	_gearParameters= &marlin::Global::GEAR->getTPCParameters();


}


void AnalysisCutSelectorProcessor::processRunHeader(lcio::LCRunHeader* run)
{
	run->parameters().setValue( _processorName + "_revision", "$Rev: 4051 $");

	for ( ProcParamMap::iterator i = _map.begin(); i != _map.end(); i++ )
	{
		if ( ! i->second->isOptional() || i->second->valueSet() )
		{
			run->parameters().setValue( _processorName + "_" + i->second->name(),
					i->second->value() );
		}
	}
} 


void AnalysisCutSelectorProcessor::processEvent(lcio::LCEvent * evt )
{ 
	//read input data
	streamlog_out(DEBUG4) << "Event: " << evt->getEventNumber() << std::endl;

	LCCollectionVec* inputCol = 0;
	try
	{
		inputCol = dynamic_cast<LCCollectionVec*>(evt->getCollection( _inputColName )) ;
	} //end of try {
	catch(DataNotAvailableException&)
	{
		// if there is not input collection give a message to the user
		streamlog_out(MESSAGE4)<<" processEvent:" <<" input collection "<<_inputColName
				<<" cannot be found in event "<<evt->getEventNumber()<<std::endl;
		return;
	}
	//fill every event in first bin of the cut flow histogram
	_cutFlowEvents->Fill(0);
	// first perform the event specific cuts
	if ( (parameterSet("lowCutNTracks") && inputCol->getNumberOfElements() < _lowcutNTracks)
			|| (parameterSet("highCutNTracks") && inputCol->getNumberOfElements() > _highcutNTracks)) return;
	//fill events that survived the number of tracks cut
	_cutFlowEvents->Fill(1);

	// create the output collection
	LCCollectionVec* outputCol = new LCCollectionVec( LCIO::TRACK );
	// set the transient flag as defined by the processor parameter
	outputCol->setTransient( (_outputIsTransient != 0) );
	// the output collection is a subset of the input collection
	// only the pointers are stored, the track is not copied
	outputCol->setSubset();

	for ( LCCollectionVec::iterator trackIter = inputCol->begin(); trackIter < inputCol->end(); trackIter++)
	{
		streamlog_out(DEBUG1)<<"looping tracks"<<std::endl;

		Track* track = dynamic_cast<Track*>( *trackIter ) ;

		//cast returns 0-pointer if cast fails
		if (track == 0)
		{
			streamlog_out(WARNING2) << "bad_cast: Track candidates collection"
					<< _inputColName
					<< " does not contain EVENT::Tracks!" << std::endl;
			throw DataNotAvailableException("No track candidates found.");
		}
		//fill all tracks in first bin of the cut flow histogram
		_cutFlowTracks->Fill(0);

		// now check all cuts and continue without saving the track if cut is not fulfilled

		if ( (parameterSet("lowCutNHitsOnTrack") &&  track->getTrackerHits().size() <
				static_cast<size_t>(_lowcutNHitsOnTrack))
				|| (parameterSet("highCutNHitsOnTrack") &&  track->getTrackerHits().size() >
		static_cast<size_t>(_highcutNHitsOnTrack)) ) continue;
		//fill tracks that survived the number hits on track cut
		_cutFlowTracks->Fill(1);

		if ( (parameterSet("lowCutPhi") &&  track->getPhi() < _lowcutPhi)
				|| (parameterSet("highCutPhi") &&  track->getPhi() > _highcutPhi) ) continue;
		//fill tracks that survived the phi cut
		_cutFlowTracks->Fill(2);

		if ( (parameterSet("lowCutTanLambda") &&  track->getTanLambda() < _lowcutTanLambda)
				|| (parameterSet("highCutTanLambda") &&  track->getTanLambda() > _highcutTanLambda) )continue;
		//fill tracks that survived the tan lambda cut
		_cutFlowTracks->Fill(3);

		if ( (parameterSet("lowCutD0") &&  track->getD0() < _lowcutD0 )
				|| (parameterSet("highCutD0") &&  track->getD0() > _highcutD0) ) continue;
		//fill tracks that survived the D0 cut
		_cutFlowTracks->Fill(4);

		if ( (parameterSet("lowCutZ0") &&  track->getZ0() < _lowcutZ0 )
				|| (parameterSet("highCutZ0") &&  track->getZ0() > _highcutZ0) ) continue;
		//fill tracks that survived the Z0 cut
		_cutFlowTracks->Fill(5);

		if ( (parameterSet("lowCutOmega") &&  track->getOmega() < _lowcutOmega)
				|| (parameterSet("highCutOmega") &&  track->getOmega() > _highcutOmega) ) continue;
		//fill tracks that survived the omega cut
		_cutFlowTracks->Fill(6);

		if ( (parameterSet("lowCutdEdx") &&  track->getdEdx() < _lowcutdEdx)
				|| ( parameterSet("highCutdEdx") &&  track->getdEdx() > _highcutdEdx) )	continue;
		//fill tracks that survived the dEdx cut
		_cutFlowTracks->Fill(7);

		if ( _cutIfFitFailed && LCFlagImpl(track->getType()).bitSet( TrackFitterBase::FITFAILEDBIT ) ) continue;
		//fill tracks that survived the dEdx cut
		_cutFlowTracks->Fill(8);

		if ( (parameterSet("lowCutChiSq") &&  track->getChi2() < _lowcutChiSq)
				|| ( parameterSet("highCutChiSq") &&  track->getChi2() > _highcutChiSq) ) continue;
		//fill tracks that survived the Chi Square cut
		_cutFlowTracks->Fill(9);

		streamlog_out(DEBUG4)<<"track->getPhi()="<<track->getPhi()<< std::endl;
		streamlog_out(DEBUG4)<<"event="<<evt->getEventNumber()<< std::endl;
		//fill the histogram of the z positions of the hits
		TrackerHitVec hitVec = track->getTrackerHits();
		streamlog_out(DEBUG4)<<"number of hits " << hitVec.size()<<std::endl;
		for ( TrackerHitVec::iterator hitIter = hitVec.begin(); hitIter < hitVec.end(); hitIter++ )
		{

			_hitZPosition->Fill((*hitIter)->getPosition()[2]);
			_hitTime->Fill((*hitIter)->getTime());

			//calculate angle between hit and track
			const gear::TPCModule& theModule = _gearParameters->getNearestModule((*hitIter)->getPosition()[0],(*hitIter)->getPosition()[1]);
		    int padIndex = theModule.getNearestPad((*hitIter)->getPosition()[0],(*hitIter)->getPosition()[1]);
			gear::Vector2D padCenterGlobal = theModule.getPadCenter(padIndex);
			gear::Vector2D e_pad (padCenterGlobal[0]-theModule.getOffset()[0],padCenterGlobal[1]-theModule.getOffset()[1]);
			double phi_s=atan2(sin(track->getPhi())-track->getOmega()*((*hitIter)->getPosition()[0]-(-track->getD0()*sin(track->getPhi())+track->getReferencePoint()[0])),
						cos(track->getPhi())+track->getOmega()*((*hitIter)->getPosition()[1]-(track->getD0()*cos(track->getPhi())+track->getReferencePoint()[1])));

			double  phiHit=phi_s-atan(e_pad[1]/e_pad[0]);
		    _hitPhi->Fill(phiHit);
		    if(theModule.getModuleID()==_bestModule &&
		    		theModule.getRowNumber(padIndex)==_bestRow)
		    {
		    	_hitPhiBestRow->Fill(phiHit);
		    }

		}

		//add surviving tracks into the output collection
		outputCol->addElement( *trackIter );
	}// for trackIter

	// only add non-empty collections to the event
	if ( outputCol->empty() ) delete outputCol;
	else  evt->addCollection(outputCol, _outputColName);

}// process event


void AnalysisCutSelectorProcessor::end()
{
	HistogramWidthExtractionTools *myTool= new HistogramWidthExtractionTools();
	myTool->Calculate(_hitZPosition,1);

	if(parameterSet("RunZOverride"))
		_runZPosTuple->Fill( _runZOverride, _runZErrorOverride,
				_runZErrorOverride, _runZErrorOverride,
				0, 600, 1 );

	else
		_runZPosTuple->Fill( myTool->GetMean(),myTool->GetMeanError()
				,myTool->GetWidth(),myTool->GetWidthError()
				,myTool->GetRange().first,myTool->GetRange().second, _hitZPosition->GetEntries() );

	myTool->Calculate(_hitTime,1);
	_runHitTimeTuple->Fill( myTool->GetMean(),myTool->GetMeanError()
					,myTool->GetWidth(),myTool->GetWidthError()
					,myTool->GetRange().first,myTool->GetRange().second, _hitTime->GetEntries() );

	myTool->Calculate(_hitPhi,1);
	_runHitPhiTuple->Fill( myTool->GetMean(),myTool->GetMeanError()
						,myTool->GetWidth(),myTool->GetWidthError()
						,myTool->GetRange().first,myTool->GetRange().second, _hitPhi->GetEntries() );

	myTool->Calculate(_hitPhiBestRow,2);
		_runHitPhiBestRowTuple->Fill( _bestModule, _bestRow, myTool->GetMean(),myTool->GetMeanError()
							,myTool->GetWidth(),myTool->GetWidthError()
							,myTool->GetRange().first,myTool->GetRange().second, _hitPhiBestRow->GetEntries() );

	streamlog_out(DEBUG4)<<"Width: "<<myTool->GetWidth()<<" +- "<<myTool->GetWidthError()<<std::endl;
	streamlog_out(DEBUG4)<<"Mean: "<<myTool->GetMean()<<" +- "<<myTool->GetMeanError()<<std::endl;
	streamlog_out(DEBUG4)<<"Range: "<<myTool->GetRange().first<<" - "<<myTool->GetRange().second<<std::endl;
	delete myTool;
}
}// namespace marlintpc

